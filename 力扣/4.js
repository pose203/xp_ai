/**
 * 寻找两个正序数组的中位数 - LeetCode 第4题
 * 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
 * 请你找出并返回这两个正序数组的中位数。
 * 
 * 算法要求：时间复杂度为 O(log (m+n))
 * 
 * 解题思路：将两个数组划分成左右两部分，使左部分和右部分的元素个数相等（或左部分比右部分多一个），
 * 且左部分的最大值小于等于右部分的最小值，此时就找到了中位数的位置。
 * 
 * @param {number[]} a - 第一个有序数组
 * @param {number[]} b - 第二个有序数组
 * @return {number} - 两个有序数组的中位数
 */
var findMedianSortedArrays = function(a, b) {
    // 确保 a 的长度不大于 b 的长度，这样可以保证下面的 i 可以从 0 开始枚举
    if (a.length > b.length) {
        [a, b] = [b, a]; // 交换数组，保证 a 是较短的数组
    }

    const m = a.length, n = b.length;
    // 在数组两端添加哨兵值，简化边界条件的处理
    a = [-Infinity, ...a, Infinity];
    b = [-Infinity, ...b, Infinity];

    // 二分查找的思想：
    // 我们需要将两个数组划分成左右两部分，使得：
    // 1. 左部分和右部分元素个数相等（或左部分比右部分多一个）
    // 2. 左部分的最大值小于等于右部分的最小值
    // 枚举 nums1 有 i 个数在左半部分
    // 那么 nums2 有 j = (m + n + 1) / 2 - i 个数在左半部分
    let i = 0, j = Math.floor((m + n + 1) / 2);
    while (true) {
        // 找到满足条件的划分点：a[i] <= b[j+1] 且 b[j] <= a[i+1]
        if (a[i] <= b[j + 1] && a[i + 1] > b[j]) { // 写 >= 也可以
            const max1 = Math.max(a[i], b[j]); // 左半部分的最大值
            const min2 = Math.min(a[i + 1], b[j + 1]); // 右半部分的最小值
            
            // 如果总长度是奇数，中位数就是左半部分的最大值
            // 如果总长度是偶数，中位数就是左半部分的最大值和右半部分的最小值的平均值
            return (m + n) % 2 ? max1 : (max1 + min2) / 2;
        }
        // 如果不满足条件，调整划分点
        i++; // 增加 a 中的元素数量
        j--; // 减少 b 中的元素数量
    }
};

